{"version":3,"sources":["/Users/liliuyun/git/frontend-stories/src/typescript/an experience with react-docgen-typescript.mdx"],"names":["layoutProps","MDXLayout","MDXContent","_ref","components","props","Object","_Users_liliuyun_git_frontend_stories_node_modules_babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_0__","_mdx_js_react__WEBPACK_IMPORTED_MODULE_2__","assign","mdxType","id","parentName","className","isMDXComponent"],"mappings":"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","file":"static/js/src-typescript-an-experience-with-react-docgen-typescript.7719cbba.js","sourcesContent":["/* @jsx mdx */\n  import React from 'react'\n  import { mdx } from '@mdx-js/react'\n  /* @jsx mdx */\n\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\")\n  return <div {...props}/>\n};\n\nconst layoutProps = {\n  \n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <h1 {...{\n      \"id\": \"记录一次react-docgen-typescript经历\"\n    }}>{`记录一次react-docgen-typescript经历`}</h1>\n    <h2 {...{\n      \"id\": \"background\"\n    }}>{`Background`}</h2>\n    <p>{`之前有一个idea是做一个组件可视化编辑器，可以通过dnd的方式来编辑组件和生成代码。其中的设想包括使用react-docgen-typescript来抓取组件的propTypes，生成组件props的可视化编辑面板。遇到的问题是对类组件使用如下的方式`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`const path = require('path')\nconsole.log(\n  require('react-docgen-typescript')\n  .parse(\n    path.join(__dirname, 'Test.tsx'),\n  )\n)\n`}</code></pre>\n    <p>{`打印出的内容为空数组，而函数组件正常。`}</p>\n    <h2 {...{\n      \"id\": \"understanding-parsewithprogramprovider\"\n    }}>{`Understanding parseWithProgramProvider`}</h2>\n    <p>{`调试的过程是使用vscode配置debug工具，把断点打在.parse方法上。  `}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`/**\n * Parses a file with default TS options\n * @param filePath component file that should be parsed\n */\nfunction parse(filePathOrPaths, parserOpts) {\n    if (parserOpts === void 0) { parserOpts = exports.defaultParserOpts; }\n    return withCompilerOptions(defaultOptions, parserOpts).parse(filePathOrPaths);\n}\n`}</code></pre>\n    <p>{`parse方法的内容是检查是否存在默认的parserOpts，然后调用withCompilerOptions方法返回的对象的parse方法。  `}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`/**\n * Constructs a parser for a specified set of TS compiler options.\n */\nfunction withCompilerOptions(compilerOptions, parserOpts) {\n    if (parserOpts === void 0) { parserOpts = exports.defaultParserOpts; }\n    return {\n        parse: function (filePathOrPaths) {\n            return parseWithProgramProvider(filePathOrPaths, compilerOptions, parserOpts);\n        },\n        parseWithProgramProvider: function (filePathOrPaths, programProvider) {\n            return parseWithProgramProvider(filePathOrPaths, compilerOptions, parserOpts, programProvider);\n        }\n    };\n}\n`}</code></pre>\n    <p>{`直到这里还没有到代码的核心部分，逻辑基本上都在处理默认参数问题，直到调用parseWithProgramProvider`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`function parseWithProgramProvider(filePathOrPaths, compilerOptions, parserOpts, programProvider) {\n    var filePaths = Array.isArray(filePathOrPaths)\n        ? filePathOrPaths\n        : [filePathOrPaths];\n    var program = programProvider\n        ? programProvider()\n        : ts.createProgram(filePaths, compilerOptions);\n    var parser = new Parser(program, parserOpts);\n    var checker = program.getTypeChecker();\n    return filePaths\n        .map(function (filePath) { return program.getSourceFile(filePath); })\n        .filter(function (sourceFile) {\n        return typeof sourceFile !== 'undefined';\n    })\n        .reduce(function (docs, sourceFile) {\n        var moduleSymbol = checker.getSymbolAtLocation(sourceFile);\n        if (!moduleSymbol) {\n            return docs;\n        }\n        Array.prototype.push.apply(docs, checker\n            .getExportsOfModule(moduleSymbol)\n            .map(function (exp) {\n            return parser.getComponentInfo(exp, sourceFile, parserOpts.componentNameResolver);\n        })\n            .filter(function (comp) { return comp !== null; })\n            .filter(function (comp, index, comps) {\n            return comps\n                .slice(index + 1)\n                .every(function (innerComp) { return innerComp.displayName !== comp.displayName; });\n        }));\n        return docs;\n    }, []);\n}\n`}</code></pre>\n    <p>{`核心代码分为几个部分`}</p>\n    <ul>\n      <li parentName=\"ul\">{`预处理：格式化filePaths为Array`}</li>\n      <li parentName=\"ul\">{`实例化：program、parser和checker需要获取到实例。program和checker是Typescript API中的概念，稍后对Typescript API进行说明。parser是react-docgen-typescript中直接操作Typescript API的类。其中定义了很多使用Typescript API来抓取.tsx?文件结构和内容的方法，同样稍后进行说明。`}</li>\n      <li parentName=\"ul\">{`返回值处理：将所有的输入文件路径，经过如下步骤的管道：1.根据文件路径获取文件信息；2.过滤找不到文件信息的项目；3.对每一个文件，寻找其模块导出的内容，转化为组件信息，过滤空数据后加入到返回的队列中。`}</li>\n    </ul>\n    <h2 {...{\n      \"id\": \"typescript-api\"\n    }}>{`Typescript API`}</h2>\n    <p>{`在了解react-docgen-typescript的解析逻辑之前，需要先对Typescript API相关的内容进行介绍。`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`    /**\n     * Create a new 'Program' instance. A Program is an immutable collection of 'SourceFile's and a 'CompilerOptions'\n     * that represent a compilation unit.\n     *\n     * Creating a program proceeds from a set of root files, expanding the set of inputs by following imports and\n     * triple-slash-reference-path directives transitively. '@types' and triple-slash-reference-types are also pulled in.\n     *\n     * @param rootNames - A set of root files.\n     * @param options - The compiler options which should be used.\n     * @param host - The host interacts with the underlying file system.\n     * @param oldProgram - Reuses an old program structure.\n     * @param configFileParsingDiagnostics - error during config file parsing\n     * @returns A 'Program' object.\n     */\n    function createProgram(rootNames: ReadonlyArray<string>, options: CompilerOptions, host?: CompilerHost, oldProgram?: Program, configFileParsingDiagnostics?: ReadonlyArray<Diagnostic>): Program;\n    /** @deprecated */ interface ResolveProjectReferencePathHost {\n        fileExists(fileName: string): boolean;\n    }\n`}</code></pre>\n    <p>{`createProgram静态方法创建了一个“Program”对象，代表了一个编译单元（一个编译单元包括需要转换的文件队列和编译选项）。`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`    /**\n     * Gets a type checker that can be used to semantically analyze source files in the program.\n     */\n    getTypeChecker(): TypeChecker;\n`}</code></pre>\n    <p>{`Program的getTypeChecker成员方法可以获取一个TypeChecker，它用来分析源文件的语义。`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`    /**\n     * Get the source file in the program with file name\n     */\n    getSourceFile(fileName: string): SourceFile | undefined;\n`}</code></pre>\n    <p>{`Program的getSourceFile成员方法用以根据文件路径获取到SourceFile（源文件信息）。SourceFile上有一些针对源文件代码行、字符与位置的互相转换的方法，也可以通过update方法更新源文件。`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`  getSymbolAtLocation(node: Node): Symbol | undefined;\n`}</code></pre>\n    <p>{`Checker的getSymbolAtLocation成员方法可以获得节点的描述符（可以这么翻译吗）,作为一个esm模块返回的内容包括{ exports: Map, declarations: `}{`[SourceFileObject]`}{` }等等，该描述符的flags为512（SymbolFlags.ValueModule）。`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`  getExportsOfModule(moduleSymbol: Symbol): Symbol[];\n`}</code></pre>\n    <p>{`Checker的getExportsOfModule成员方法用来直接拿到模块的导出（Array形式），一个基础的tsx组件，包括导入react、导出props接口定义、默认导出类定义，调用getExportsOfModule则会拿到2个模块的导出，第一个的flags为64（SymbolFlags.Interface），第二个为32（SymbolFlags.Class）。\nParser的成员方法parseWithProgramProvider中依赖的Typescript API均已介绍完毕，在该方法中调用了自身实例的getComponentInfo方法还依赖以下一些Typescript API。`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`  getTypeOfSymbolAtLocation(symbol: Symbol, node: Node): Type;\n`}</code></pre>\n    <p>{`Checker的getTypeOfSymbolAtLocation成员方法用来获取描述符的类型定义。`}</p>\n    <h2 {...{\n      \"id\": \"understanding-getcomponentinfo\"\n    }}>{`Understanding getComponentInfo`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`    Parser.prototype.getComponentInfo = function (exp, source, componentNameResolver) {\n        if (componentNameResolver === void 0) { componentNameResolver = function () { return undefined; }; }\n        if (!!exp.declarations && exp.declarations.length === 0) {\n            return null;\n        }\n        var type = this.checker.getTypeOfSymbolAtLocation(exp, exp.valueDeclaration || exp.declarations[0]);\n        var commentSource = exp;\n        if (!exp.valueDeclaration) {\n            if (!type.symbol) {\n                return null;\n            }\n            exp = type.symbol;\n            var expName = exp.getName();\n            if (expName === 'StatelessComponent' ||\n                expName === 'Stateless' ||\n                expName === 'StyledComponentClass' ||\n                expName === 'FunctionComponent') {\n                commentSource = this.checker.getAliasedSymbol(commentSource);\n            }\n            else {\n                commentSource = exp;\n            }\n        }\n        // Skip over PropTypes that are exported\n        if (type.symbol &&\n            (type.symbol.getEscapedName() === 'Requireable' ||\n                type.symbol.getEscapedName() === 'Validator')) {\n            return null;\n        }\n        var propsType = this.extractPropsFromTypeIfStatelessComponent(type) ||\n            this.extractPropsFromTypeIfStatefulComponent(type);\n        var resolvedComponentName = componentNameResolver(exp, source);\n        var displayName = resolvedComponentName || computeComponentName(exp, source);\n        var description = this.findDocComment(commentSource).fullComment;\n        var methods = this.getMethodsInfo(type);\n        if (propsType) {\n            var defaultProps = this.extractDefaultPropsFromComponent(exp, source);\n            var props = this.getPropsInfo(propsType, defaultProps);\n            for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {\n                var propName = _a[_i];\n                var prop = props[propName];\n                var component = { name: displayName };\n                if (!this.propFilter(prop, component)) {\n                    delete props[propName];\n                }\n            }\n            return {\n                description: description,\n                displayName: displayName,\n                methods: methods,\n                props: props\n            };\n        }\n        else if (description && displayName) {\n            return {\n                description: description,\n                displayName: displayName,\n                methods: methods,\n                props: {}\n            };\n        }\n        return null;\n    };\n`}</code></pre>\n    <p>{`Parser的getComponentInfo成员方法有关于props的部分是：先根据parseWithProgramProvider中拿到的导出模块使用checker中的getTypeOfSymbolAtLocation方法拿到类型定义，然后调用自身的extractPropsFromTypeIfStatelessComponent方法，如果是函数组件则可以拿到props信息，如果返回为空则尝试使用extractPropsFromTypeIfStatefulComponent方法，从类组件中拿到对应的props信息。最后调用自身的getPropsInfo方法从propsType中提取到类型定义。`}</p>\n    <h2 {...{\n      \"id\": \"understanding-extractpropsfromtypeifstatelesscomponent\"\n    }}>{`Understanding extractPropsFromTypeIfStatelessComponent`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`    Parser.prototype.extractPropsFromTypeIfStatelessComponent = function (type) {\n        var callSignatures = type.getCallSignatures();\n        if (callSignatures.length) {\n            // Could be a stateless component.  Is a function, so the props object we're interested\n            // in is the (only) parameter.\n            for (var _i = 0, callSignatures_1 = callSignatures; _i < callSignatures_1.length; _i++) {\n                var sig = callSignatures_1[_i];\n                var params = sig.getParameters();\n                if (params.length === 0) {\n                    continue;\n                }\n                // Maybe we could check return type instead,\n                // but not sure if Element, ReactElement<T> are all possible values\n                var propsParam = params[0];\n                if (propsParam.name === 'props' || params.length === 1) {\n                    return propsParam;\n                }\n            }\n        }\n        return null;\n    };\n`}</code></pre>\n    <p>{`函数组件都是(props: IProps) => React.ReactNode的形式，所以只要拿到函数类型的调用签名的入参第一项就可以了。`}</p>\n    <h2 {...{\n      \"id\": \"understanding-extractpropsfromtypeifstatefulcomponent\"\n    }}>{`Understanding extractPropsFromTypeIfStatefulComponent`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`    Parser.prototype.extractPropsFromTypeIfStatefulComponent = function (type) {\n        var constructSignatures = type.getConstructSignatures();\n        if (constructSignatures.length) {\n            // React.Component. Is a class, so the props object we're interested\n            // in is the type of 'props' property of the object constructed by the class.\n            for (var _i = 0, constructSignatures_1 = constructSignatures; _i < constructSignatures_1.length; _i++) {\n                var sig = constructSignatures_1[_i];\n                var instanceType = sig.getReturnType();\n                var props = instanceType.getProperty('props');\n                if (props) {\n                    return props;\n                }\n            }\n        }\n        return null;\n    };\n`}</code></pre>\n    <p>{`如果是类组件，react-docgen-typescript的实现方式是先获取类的类型的构造器签名，然后拿到它的返回值类型中的props定义。`}</p>\n    <h2 {...{\n      \"id\": \"todo\"\n    }}>{`todo`}</h2>\n    <p>{`还没完`}</p>\n    <h2 {...{\n      \"id\": \"conclusion\"\n    }}>{`Conclusion`}</h2>\n    <p>{`在使用typescript相关API时需要先加载对应的类型定义文件啊！！！`}</p>\n    </MDXLayout>;\n}\n\nMDXContent.isMDXComponent = true;\n  "],"sourceRoot":""}