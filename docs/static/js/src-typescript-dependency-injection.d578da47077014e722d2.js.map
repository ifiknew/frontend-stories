{"version":3,"sources":["/Users/liliuyun/git/frontend-stories/src/typescript/dependency injection.mdx"],"names":["layoutProps","MDXLayout","MDXContent","_ref","components","props","Object","_Users_liliuyun_git_frontend_stories_node_modules_babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_0__","_mdx_js_react__WEBPACK_IMPORTED_MODULE_2__","assign","mdxType","id","parentName","className","isMDXComponent"],"mappings":"kZAWMA,EAAc,GAGdC,EAAY,UACH,SAASC,EAATC,GAGZ,IAFDC,EAECD,EAFDC,WACGC,EACFC,OAAAC,EAAA,EAAAD,CAAAH,EAAA,gBACD,OAAOG,OAAAE,EAAA,EAAAF,CAACL,EAADK,OAAAG,OAAA,GAAeT,EAAiBK,EAAhC,CAAuCD,WAAYA,EAAYM,QAAQ,cAC5EJ,OAAAE,EAAA,EAAAF,CAAA,KAAQ,CACNK,GAAM,sCADR,sCAGAL,OAAAE,EAAA,EAAAF,CAAA,KAAQ,CACNK,GAAM,cADR,cAGAL,OAAAE,EAAA,EAAAF,CAAA,iPACAA,OAAAE,EAAA,EAAAF,CAAA,KAAQ,CACNK,GAAM,UADR,UAGAL,OAAAE,EAAA,EAAAF,CAAA,skBAAgHA,OAAAE,EAAA,EAAAF,CAAA,MAAIM,WAAW,MAA/H,0SAIAN,OAAAE,EAAA,EAAAF,CAAA,KAAQ,CACNK,GAAM,WADR,WAGAL,OAAAE,EAAA,EAAAF,CAAA,+eACAA,OAAAE,EAAA,EAAAF,CAAA,KAAQ,CACNK,GAAM,YADR,YAGAL,OAAAE,EAAA,EAAAF,CAAA,kQACAA,OAAAE,EAAA,EAAAF,CAAA,WAAKA,OAAAE,EAAA,EAAAF,CAAA,OAAAA,OAAAG,OAAA,CAAMG,WAAW,OAAU,CAC5BC,UAAa,gBADZ,gCAILP,OAAAE,EAAA,EAAAF,CAAA,mHACAA,OAAAE,EAAA,EAAAF,CAAA,WAAKA,OAAAE,EAAA,EAAAF,CAAA,OAAAA,OAAAG,OAAA,CAAMG,WAAW,OAAU,CAC5BC,UAAa,gBADZ,+fAkBLP,OAAAE,EAAA,EAAAF,CAAA,sZACAA,OAAAE,EAAA,EAAAF,CAAA,WAAKA,OAAAE,EAAA,EAAAF,CAAA,OAAAA,OAAAG,OAAA,CAAMG,WAAW,OAAU,CAC5BC,UAAa,gBADZ,+PAeLP,OAAAE,EAAA,EAAAF,CAAA,wQACAA,OAAAE,EAAA,EAAAF,CAAA,KAAQ,CACNK,GAAM,eADR,eAGAL,OAAAE,EAAA,EAAAF,CAAA,yIACAA,OAAAE,EAAA,EAAAF,CAAA,WAAKA,OAAAE,EAAA,EAAAF,CAAA,OAAAA,OAAAG,OAAA,CAAMG,WAAW,OAAU,CAC5BC,UAAa,gBADZ,8zCA6BLP,OAAAE,EAAA,EAAAF,CAAA,0iBAIJJ,EAAWY,gBAAiB","file":"static/js/src-typescript-dependency-injection.983f9518.js","sourcesContent":["/* @jsx mdx */\n  import React from 'react'\n  import { mdx } from '@mdx-js/react'\n  /* @jsx mdx */\n\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\")\n  return <div {...props}/>\n};\n\nconst layoutProps = {\n  \n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <h1 {...{\n      \"id\": \"typescript依赖注入\"\n    }}>{`Typescript依赖注入`}</h1>\n    <h2 {...{\n      \"id\": \"background\"\n    }}>{`Background`}</h2>\n    <p>{`之前看到一个库typedi实现了DI方案，觉得比较炫酷，于是打算自己写一个mini版的依赖注入。`}</p>\n    <h2 {...{\n      \"id\": \"theory\"\n    }}>{`Theory`}</h2>\n    <p>{`依赖注入的基本原理是利用一些手段（如静态分析方法）来标记需要注入的对象的符号，同时提供标记方法（通常是注解，js领域上则是decorator）来在全局收集可以被注入到其他对象上的实例对应的类。所以要点只有3个：`}<br parentName=\"p\"></br>{`\n`}{`1. 全局查找和注册的服务\n2. 使用装饰器进行注册和注入，ts(和js)现已原生支持\n3. 对注入进行分析和自动查找并注入`}</p>\n    <h2 {...{\n      \"id\": \"problem\"\n    }}>{`Problem`}</h2>\n    <p>{`困难主要在于如何获取注入对象的类型。由于Typescript在编译为js后是不保留类型信息的，所以必须通过一些支持方法来让装饰器知道注入的类型信息。事实上，ts对此也有原生的支持方式。`}</p>\n    <h2 {...{\n      \"id\": \"solution\"\n    }}>{`Solution`}</h2>\n    <p>{`在tsconfig的\"compilerOptions\"中设置\"experimentalDecorators\": true，\"emitDecoratorMetadata\": true, 在全局环境下首先引入reflect-metadata库对Reflect API作扩展。`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`import 'reflect-metadata'\n`}</code></pre>\n    <p>{`对应的服务注册和查找的简单实现如下`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`const store = new Map<any, any>();\n\nconst Registry = {\n  naming: <T extends new () => any>(constructor: T) => {\n    store.set(constructor, new constructor())\n  },\n  lookup: <T extends new () => any>(constructor: T) => {\n    return store.get(constructor) as InstanceType<T>\n  },\n  inject: <T>(target: T, propertyKey: string | symbol) => {\n    const key = Reflect.getMetadata(\"design:type\", target, propertyKey);\n    (target as any)[propertyKey] = store.get(key)\n  }\n}\nexport default Registry\n`}</code></pre>\n    <p>{`其中naming装饰器用户在映射表中注入类，inject则查找并进行注入。可以注意一下其中的Reflect.getMetadata方法，这是由reflect-metadata扩展实现的，需要和Typescript的编译相结合。`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`import Registry from \"../utils/Registry\"\nimport ModelService from \"./ModelService\"\n@Registry.naming\nclass LanguageService {\n\n  @Registry.inject\n  private modelService!: ModelService\n  constructor() {\n  }\n}\n\nexport default LanguageService\n`}</code></pre>\n    <p>{`这是一个注册和注入的例子，相关的方法在Registry中注册了LanguageService的实例，并自动注入ModelService的实例。`}</p>\n    <h2 {...{\n      \"id\": \"in-the-deep\"\n    }}>{`In the deep`}</h2>\n    <p>{`具体的原理，可以查看Typescript编译后的文件来理解`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`\"use strict\";\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Registry_1 = require(\"../utils/Registry\");\nconst ModelService_1 = require(\"./ModelService\");\nlet LanguageService = class LanguageService {\n    constructor() {\n    }\n};\n__decorate([\n    Registry_1.default.inject,\n    __metadata(\"design:type\", ModelService_1.default)\n], LanguageService.prototype, \"modelService\", void 0);\nLanguageService = __decorate([\n    Registry_1.default.naming,\n    __metadata(\"design:paramtypes\", [])\n], LanguageService);\nexports.default = LanguageService;\n`}</code></pre>\n    <p>{`很容易理解的是，在开启记录meta的情况下，Typescript在编译时额外注入来类型信息以供装饰器使用。具体可以查阅(reflect-metadata)`}{`[https://github.com/rbuckton/reflect-metadata]`}</p>\n    </MDXLayout>;\n}\n\nMDXContent.isMDXComponent = true;\n  "],"sourceRoot":""}