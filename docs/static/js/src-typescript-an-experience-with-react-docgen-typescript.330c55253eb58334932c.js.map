{"version":3,"sources":["/Users/liliuyun/git/frontend-stories/src/typescript/an experience with react-docgen-typescript.mdx"],"names":["layoutProps","MDXLayout","MDXContent","_ref","components","props","Object","_Users_liliuyun_git_frontend_stories_node_modules_babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_0__","_mdx_js_react__WEBPACK_IMPORTED_MODULE_2__","assign","mdxType","id","parentName","className","isMDXComponent"],"mappings":"waAWMA,EAAc,GAGdC,EAAY,UACH,SAASC,EAATC,GAGZ,IAFDC,EAECD,EAFDC,WACGC,EACFC,OAAAC,EAAA,EAAAD,CAAAH,EAAA,gBACD,OAAOG,OAAAE,EAAA,EAAAF,CAACL,EAADK,OAAAG,OAAA,GAAeT,EAAiBK,EAAhC,CAAuCD,WAAYA,EAAYM,QAAQ,cAC5EJ,OAAAE,EAAA,EAAAF,CAAA,KAAQ,CACNK,GAAM,2EADR,2EAGAL,OAAAE,EAAA,EAAAF,CAAA,KAAQ,CACNK,GAAM,cADR,cAGAL,OAAAE,EAAA,EAAAF,CAAA,6gBACAA,OAAAE,EAAA,EAAAF,CAAA,WAAKA,OAAAE,EAAA,EAAAF,CAAA,OAAAA,OAAAG,OAAA,CAAMG,WAAW,OAAU,CAC5BC,UAAa,gBADZ,iJAULP,OAAAE,EAAA,EAAAF,CAAA,iFACAA,OAAAE,EAAA,EAAAF,CAAA,KAAQ,CACNK,GAAM,SADR,SAGAL,OAAAE,EAAA,EAAAF,CAAA,oKACAA,OAAAE,EAAA,EAAAF,CAAA,WAAKA,OAAAE,EAAA,EAAAF,CAAA,OAAAA,OAAAG,OAAA,CAAMG,WAAW,OAAU,CAC5BC,UAAa,gBADZ,oUAWLP,OAAAE,EAAA,EAAAF,CAAA,gPACAA,OAAAE,EAAA,EAAAF,CAAA,WAAKA,OAAAE,EAAA,EAAAF,CAAA,OAAAA,OAAAG,OAAA,CAAMG,WAAW,OAAU,CAC5BC,UAAa,gBADZ,mlBAiBLP,OAAAE,EAAA,EAAAF,CAAA,6PACAA,OAAAE,EAAA,EAAAF,CAAA,WAAKA,OAAAE,EAAA,EAAAF,CAAA,OAAAA,OAAAG,OAAA,CAAMG,WAAW,OAAU,CAC5BC,UAAa,gBADZ,22CAoCLP,OAAAE,EAAA,EAAAF,CAAA,yEACAA,OAAAE,EAAA,EAAAF,CAAA,UACEA,OAAAE,EAAA,EAAAF,CAAA,MAAIM,WAAW,MAAf,kEACAN,OAAAE,EAAA,EAAAF,CAAA,MAAIM,WAAW,MAAf,oiBACAN,OAAAE,EAAA,EAAAF,CAAA,MAAIM,WAAW,MAAf,qkBAEFN,OAAAE,EAAA,EAAAF,CAAA,KAAQ,CACNK,GAAM,kBADR,kBAGAL,OAAAE,EAAA,EAAAF,CAAA,wMACAA,OAAAE,EAAA,EAAAF,CAAA,WAAKA,OAAAE,EAAA,EAAAF,CAAA,OAAAA,OAAAG,OAAA,CAAMG,WAAW,OAAU,CAC5BC,UAAa,gBADZ,wmCAqBLP,OAAAE,EAAA,EAAAF,CAAA,qTACAA,OAAAE,EAAA,EAAAF,CAAA,KAAQ,CACNK,GAAM,QADR,QAGAL,OAAAE,EAAA,EAAAF,CAAA,+BACAA,OAAAE,EAAA,EAAAF,CAAA,KAAQ,CACNK,GAAM,cADR,cAGAL,OAAAE,EAAA,EAAAF,CAAA,8XAIJJ,EAAWY,gBAAiB","file":"static/js/src-typescript-an-experience-with-react-docgen-typescript.1fab4a48.js","sourcesContent":["/* @jsx mdx */\n  import React from 'react'\n  import { mdx } from '@mdx-js/react'\n  /* @jsx mdx */\n\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\")\n  return <div {...props}/>\n};\n\nconst layoutProps = {\n  \n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <h1 {...{\n      \"id\": \"记录一次使用react-docgen-typescript的坑\"\n    }}>{`记录一次使用react-docgen-typescript的坑`}</h1>\n    <h2 {...{\n      \"id\": \"background\"\n    }}>{`Background`}</h2>\n    <p>{`之前有一个idea是做一个组件可视化编辑器，可以通过dnd的方式来编辑组件和生成代码。其中的设想包括使用react-docgen-typescript来抓取组件的propTypes，生成组件props的可视化编辑面板。遇到的问题是使用如下的方式`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`const path = require('path')\nconsole.log(\n  require('react-docgen-typescript')\n  .parse(\n    path.join(__dirname, 'Test.tsx'),\n  )\n)\n`}</code></pre>\n    <p>{`打印出的内容为空数组。  `}</p>\n    <h2 {...{\n      \"id\": \"debug\"\n    }}>{`Debug`}</h2>\n    <p>{`调试的过程是使用vscode配置debug工具，把断点打在.parse方法上。  `}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`/**\n * Parses a file with default TS options\n * @param filePath component file that should be parsed\n */\nfunction parse(filePathOrPaths, parserOpts) {\n    if (parserOpts === void 0) { parserOpts = exports.defaultParserOpts; }\n    return withCompilerOptions(defaultOptions, parserOpts).parse(filePathOrPaths);\n}\n`}</code></pre>\n    <p>{`parse方法的内容是检查是否存在默认的parserOpts，然后调用withCompilerOptions方法返回的对象的parse方法。  `}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`/**\n * Constructs a parser for a specified set of TS compiler options.\n */\nfunction withCompilerOptions(compilerOptions, parserOpts) {\n    if (parserOpts === void 0) { parserOpts = exports.defaultParserOpts; }\n    return {\n        parse: function (filePathOrPaths) {\n            return parseWithProgramProvider(filePathOrPaths, compilerOptions, parserOpts);\n        },\n        parseWithProgramProvider: function (filePathOrPaths, programProvider) {\n            return parseWithProgramProvider(filePathOrPaths, compilerOptions, parserOpts, programProvider);\n        }\n    };\n}\n`}</code></pre>\n    <p>{`直到这里还没有到代码的核心部分，逻辑基本上都在处理默认参数问题，直到调用parseWithProgramProvider`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`function parseWithProgramProvider(filePathOrPaths, compilerOptions, parserOpts, programProvider) {\n    var filePaths = Array.isArray(filePathOrPaths)\n        ? filePathOrPaths\n        : [filePathOrPaths];\n    var program = programProvider\n        ? programProvider()\n        : ts.createProgram(filePaths, compilerOptions);\n    var parser = new Parser(program, parserOpts);\n    var checker = program.getTypeChecker();\n    return filePaths\n        .map(function (filePath) { return program.getSourceFile(filePath); })\n        .filter(function (sourceFile) {\n        return typeof sourceFile !== 'undefined';\n    })\n        .reduce(function (docs, sourceFile) {\n        var moduleSymbol = checker.getSymbolAtLocation(sourceFile);\n        if (!moduleSymbol) {\n            return docs;\n        }\n        Array.prototype.push.apply(docs, checker\n            .getExportsOfModule(moduleSymbol)\n            .map(function (exp) {\n            return parser.getComponentInfo(exp, sourceFile, parserOpts.componentNameResolver);\n        })\n            .filter(function (comp) { return comp !== null; })\n            .filter(function (comp, index, comps) {\n            return comps\n                .slice(index + 1)\n                .every(function (innerComp) { return innerComp.displayName !== comp.displayName; });\n        }));\n        return docs;\n    }, []);\n}\n`}</code></pre>\n    <p>{`核心代码分为几个部分`}</p>\n    <ul>\n      <li parentName=\"ul\">{`预处理：格式化filePaths为Array`}</li>\n      <li parentName=\"ul\">{`实例化：program、parser和checker需要获取到实例。program和checker是Typescript API中的概念，稍后对Typescript API进行说明。parser是react-docgen-typescript中直接操作Typescript API的类。其中定义了很多使用Typescript API来抓取.tsx?文件结构和内容的方法，同样稍后进行说明。`}</li>\n      <li parentName=\"ul\">{`返回值处理：将所有的输入文件路径，经过如下步骤的管道：1.根据文件路径获取文件信息；2.过滤找不到文件信息的项目；3.对每一个文件，寻找其模块导出的内容，转化为组件信息，过滤空数据后加入到返回的队列中。`}</li>\n    </ul>\n    <h2 {...{\n      \"id\": \"typescript-api\"\n    }}>{`Typescript API`}</h2>\n    <p>{`在了解react-docgen-typescript的解析逻辑之前，需要先对Typescript API相关的内容进行介绍。`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`    /**\n     * Create a new 'Program' instance. A Program is an immutable collection of 'SourceFile's and a 'CompilerOptions'\n     * that represent a compilation unit.\n     *\n     * Creating a program proceeds from a set of root files, expanding the set of inputs by following imports and\n     * triple-slash-reference-path directives transitively. '@types' and triple-slash-reference-types are also pulled in.\n     *\n     * @param rootNames - A set of root files.\n     * @param options - The compiler options which should be used.\n     * @param host - The host interacts with the underlying file system.\n     * @param oldProgram - Reuses an old program structure.\n     * @param configFileParsingDiagnostics - error during config file parsing\n     * @returns A 'Program' object.\n     */\n    function createProgram(rootNames: ReadonlyArray<string>, options: CompilerOptions, host?: CompilerHost, oldProgram?: Program, configFileParsingDiagnostics?: ReadonlyArray<Diagnostic>): Program;\n    /** @deprecated */ interface ResolveProjectReferencePathHost {\n        fileExists(fileName: string): boolean;\n    }\n`}</code></pre>\n    <p>{`createProgram方法创建了一个“Program”对象，代表了一个编译单元（一个编译单元包括需要转换的文件队列和编译选项）。`}</p>\n    <h2 {...{\n      \"id\": \"todo\"\n    }}>{`todo`}</h2>\n    <p>{`还没完`}</p>\n    <h2 {...{\n      \"id\": \"conclusion\"\n    }}>{`Conclusion`}</h2>\n    <p>{`在使用typescript相关API时需要先加载对应的类型定义文件啊！！！`}</p>\n    </MDXLayout>;\n}\n\nMDXContent.isMDXComponent = true;\n  "],"sourceRoot":""}